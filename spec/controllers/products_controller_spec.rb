require 'rails_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.
#
# Also compared to earlier versions of this generator, there are no longer any
# expectations of assigns and templates rendered. These features have been
# removed from Rails core in Rails 5, but can be added back in via the
# `rails-controller-testing` gem.

RSpec.describe ProductsController, type: :controller do

  # This should return the minimal set of attributes required to create a valid
  # ProductPrice. As you add validations to ProductPrice, be sure to
  # adjust the attributes here as well.
  let(:valid_attributes) {
    {product_id: 13860428, value: 13.49, currency_code: "USD"}
  }

  describe "GET #show" do
    it "returns a success response" do
      product_price = ProductPrice.create! valid_attributes
      get :show, params: {id: product_price.to_param}
      expect(response).to be_successful
    end

    it "returns a not found response" do
      id = 15117729 # bad id

      get :show, params: {id: id}
      expect(response.status).to eq(404)

      json = JSON.parse(response.body)
      expect(json).to eq({"code" => 404, "id" => id})
    end
  end

  describe "PUT #update" do
    context "with redsky product" do
      it "returns a success response" do
        product_price = ProductPrice.create! valid_attributes
        value = 14.99
        currency_code = "USD"
        put :update, params: {id: product_price.to_param, current_price: {value: value, currency_code: currency_code}}
        expect(response).to be_successful
      end

      it "returns errors without a value or currency code" do
        product_price = ProductPrice.create! valid_attributes

        put :update, params: {id: product_price.to_param, current_price: {val: 123}}

        # 422: unprocessable entity
        expect(response.status).to eq(422)

        json = JSON.parse(response.body)
        expect(json["code"]).to eq(422)
        expect(json["id"]).to eq(product_price.product_id)
        expect(json).to have_key("errors")
        errors = json["errors"]
        expect(errors).to include({"message" => "is not a number", "pointer" => "/current_price/value"})
        expect(errors).to include({"message" => "is not included in the list", "pointer" => "/current_price/currency_code"})
      end

    end

    context "without redsky product" do
      it "returns not found, 404" do
        value = 14.99
        currency_code = "USD"
        id = 15117729
        put :update, params: {id: id, current_price: {value: value, currency_code: currency_code}}

        # 404 not found
        expect(response.status).to eq(404)
        json = JSON.parse(response.body)
        expect(json).to eq({"code" => 404, "id" => id})

        # shouldn't find anything in the database if 404 not found
        expect { ProductPrice.find(id) }.to raise_error(Cequel::Record::RecordNotFound)
      end
    end
  end
end
